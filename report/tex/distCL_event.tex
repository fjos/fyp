\documentclass[report.tex]{subfiles}
\begin{document}

\subsection{Event Based Programming} % (fold)
\label{sub:event_based_programming}


    \subsubsection{distCL\_event Design} % (fold)
    \label{ssub:distcl_event_design}
        A distCL\_event is a wrapper structure for the standard OpenCL cl\_event. Originally, a distCL\_event was a struct that could contain any number of different type of events, with the type defined by an enumeration. If the event was a receive event, it would contain a vector of ids for the C\texttt{++}11 std::thread, and waiting for the event would involve simply joining all the threads. A send event would contain a vector of MPI\_Requests, waiting for that would involve calling MPI\_Wait upon every single request in the thread. The current event was simply an OpenCL cl\_event, created as usual within OpenCL. For this, waiting was a simple call to clWaitForEvents(1, cl\_event). 

        As you might imagine, this was quite inefficient. And although the inefficiency could be ignored as it would not certainly not be the limiting factor in performance (that, of course, being the actual transference of data), it led to a rather unsightly mess of code. As the functionality of the code grew, so too did the complexity of a single event. Any given situation could have a number of different of components associated with the event. Half the time receives would have both threads and cl\_events attached to them, and the other half not. After a few aborted attempts to abstract farther away from the mess that was a distCL\_event by putting it within another wrapper structure, it became clear that a better solution was needed.

        It was decided that the code would be better served by only dealing with cl\_events. By utilizing clCreateUserEvent and clSetUserEventStatus, data transfer events could also return a cl\_event. As these custom events are chiefly used to guarantee the sequentiality of MPI communications and OpenCL functions (i.e. ensuring all data is received prior to a call to clEnqueueWriteBuffer), and the sends and receives are all threaded functions, a C++ standard library shared\_ptr was used to allow multiple threads to access a single cl\_event without worry of it falling out of scope.

        Additionally, because certain functions involve sending data to multiple machines, a single send event might involve multiple targets and thus multiple cl\_events. As such the distCL\_event needs to contain an array of cl\_events. This can be seen in Figure~\ref{fig:distCL_event_uml_current}; the current design for distCL\_event. It is a struct that contains two members; an integer (size) for the number of cl\_events associated with the distCL\_event, and an array of shared\_ptrs to cl\_events (event). In comparison to the original (Figure~\ref{fig:distCL_event_uml_original}), it was far simpler and ended with reducing the overall complexity of all code dealing with events.

        \begin{figure}[htbp]
            \centering
            \includegraphics[width=0.65\textwidth]{diagrams/distCL_event_current.1}
            \caption{distCL\_event current}
            \label{fig:distCL_event_uml_current}
        \end{figure}

        \begin{figure}[htbp]
            \centering
            \includegraphics[width=0.65\textwidth]{diagrams/distCL_event_original.1}
            \caption{distCL\_event original}
            \label{fig:distCL_event_uml_original}
        \end{figure}
        
    % subsubsection distcl_event_design (end)

    \subsubsection{distCL\_event Usage} % (fold)
    \label{ssub:distcl_event_usage}
        One of the goals in creating distCL\_event was to stay as true as possible to the OpenCL event model. In the original event iteration, there was a wrapper containing a vector of distCL\_events. This was first created with the thought of allowing a simpler usage of events; simply pass one object by reference and the rest would be taken care of. Unfortunately, events were used and modified asynchronously. This unfortunately led to some situations where pointers would be invalidated by the changing vector, how this happens can be seen below.

        GUYS FIGURE HERE FOR MUTEXTHINGY

        Instead of adding additional levels of complication by dealing with mutexes, it was much easier to switch to using std::list; a solution that should have been readily apparent from the start. Because there was no longer a danger of reallocation when modifying the container, thread safety was far easier to guarantee.
        
        It should be noted: the decision to switch from a vector to a standard array was made prior to the all events being shared\_ptrs to cl\_events. A large part of the danger of vectors could have been mitigated by using shared\_ptrs, thus removing any need to pass by reference.

        This meant that when the change to using solely cl\_event and std::shared\_ptr was made, there was the possibility of returning to using std::vector. This idea was, however, discarded. There was no reason to return to a less safe structure. There was only one problem left; using the list led to far more indirect handling of events, and a reduction in the clarity of code. 

        It was for this reason that the idea of reducing involvement in creating a list of events was reconsidered. This reevaluation led to the abandonment of containers and the return to the event model used in OpenCL; a pointer to the head of an array of events and the number of items in the array.

        Thus the usage of event based synchronization ended up being very similar to that of OpenCL's original model. This can be seen below in one of the simplest event based synchronization calls; clWaitForEvents.

        \begin{lstlisting}
        //Standard OpenCL clWaitForEvents call
        clWaitForEvents(cl_uint num_events_in_list, cl_event * event_wait_list)
        
        // distributedCL WaitForEvents
        // target_machines provides a list of machines that WaitForEvents acts upon
        distributedCL::WaitForEvents(cl_uint num_events_in_list, distCL_event * event_wait_list, init_list target_machines)
        \end{lstlisting}

        This behaviour holds true in the many OpenCL functions that can take events; a pointer to the set of events and the number of events to wait on.

    % subsubsection distcl_event_usage (end)
% subsection event_based_programming (end)
\end{document}